# Data Model: Integrated RAG Chatbot for Book

**Feature**: 002-rag-chatbot
**Date**: 2025-12-30
**Purpose**: Defines data entities, their fields, validation rules, and relationships

## Overview

This document describes the data model for the RAG chatbot backend. The system uses:
- **Pydantic models** for API request/response validation (Python)
- **Qdrant payloads** for vector storage metadata
- **In-memory session state** for conversation context (no persistence)

---

## Entity 1: Question

**Purpose**: Represents a user's inquiry about book content with optional selected text context.

### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|-------------|
| `question` | `str` | Yes | The user's question text | 1-500 characters |
| `selected_text` | `Optional[str]` | No | Text highlighted/selected by user | 0-5000 characters |
| `message_id` | `str` | Yes | Unique identifier for this message | UUID format |

### Relationships

- Belongs to: `ConversationSession` (many-to-one)
- Generates: `Answer` (one-to-one)

### Validation Rules

**FR-001 (Question Submission)**:
- `question` must not be empty after stripping whitespace
- `question` must not exceed 500 characters (prevents API abuse)
- `selected_text` can be empty (for general queries) or up to 5000 characters (multi-page selections)

**FR-003 (Text Selection)**:
- `selected_text` is optional; if present, used to filter retrieval

### Example

```json
{
  "question": "How does RAG retrieval work?",
  "selected_text": "RAG (Retrieval-Augmented Generation) combines retrieval...",
  "message_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

---

## Entity 2: Answer

**Purpose**: Represents the system's response to a question, generated by RAG agent with citations.

### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|-------------|
| `content` | `str` | Yes | The generated answer text | 1-2000 characters |
| `citations` | `List[Citation]` | Yes | References to book sections used | Non-empty if based on content |
| `confidence` | `float` | Yes | Confidence score for answer quality | 0.0-1.0 |
| `is_from_book` | `bool` | Yes | Whether answer derived from book content | Required |
| `related_message_id` | `str` | Yes | ID of question this answers | UUID format |
| `timestamp` | `datetime` | Yes | When answer was generated | ISO 8601 format |

### Sub-entity: Citation

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `chapter` | `str` | Yes | Chapter reference |
| `section` | `Optional[str]` | No | Section within chapter |
| `chunk_id` | `int` | Yes | Unique chunk identifier |
| `relevance_score` | `float` | Yes | Semantic similarity score | 0.0-1.0 |

### Relationships

- Responds to: `Question` (one-to-one, via `related_message_id`)
- Part of: `ConversationSession` (many-to-one)

### Validation Rules

**FR-002 (Book-Based Answers)**:
- `citations` list must be non-empty when `is_from_book` is `True`
- Each citation must reference existing `chunk_id` from Qdrant

**FR-007 (Non-Book Content Indication)**:
- `is_from_book` must be `False` when answer couldn't be derived from book content
- When `is_from_book` is `False`, `citations` should be empty

**Constitution (Citation-Backed)**:
- All factual claims must have supporting citations
- `confidence` should reflect retrieval quality and citation relevance

### Example

```json
{
  "content": "RAG retrieval works by querying a vector database...",
  "citations": [
    {
      "chapter": "Chapter 1",
      "section": "RAG Architecture",
      "chunk_id": 42,
      "relevance_score": 0.89
    }
  ],
  "confidence": 0.87,
  "is_from_book": true,
  "related_message_id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2025-12-30T14:30:00Z"
}
```

---

## Entity 3: BookContent (Qdrant Payload)

**Purpose**: Metadata associated with each vector in Qdrant, enabling citation and filtering.

### Fields (Qdrant Payload)

| Field | Type | Required | Description | Indexing |
|-------|------|----------|-------------|-----------|
| `chapter` | `str` | Yes | Chapter name or number | Indexed (for filtering) |
| `section` | `Optional[str]` | No | Section name within chapter | Indexed (for filtering) |
| `chunk_id` | `int` | Yes | Unique chunk identifier | Not indexed (lookup) |
| `text` | `str` | Yes | Original text chunk | Not indexed (payload) |

### Qdrant Point Structure

```python
{
    "id": 42,                           # chunk_id (used as point ID)
    "vector": [0.1, 0.2, ...],         # 1024-dimensional embedding
    "payload": {
        "chapter": "Chapter 1",
        "section": "RAG Architecture",
        "chunk_id": 42,
        "text": "RAG (Retrieval-Augmented Generation) combines retrieval..."
    }
}
```

### Relationships

- Referenced by: `Answer.citations` (many-to-one)
- Filtered by: `Question.selected_text` (metadata query)

### Validation Rules

**FR-008 (Content Indexing)**:
- All chunks must be indexed with unique `chunk_id`
- `chapter` and `section` must match source book structure

**FR-010 (Accurate Answers)**:
- Retrieval uses cosine similarity on vector field
- Selected-text queries use metadata filters (`chapter`, `section`, `chunk_id`)

**Constitution (Zero Hallucination)**:
- `text` field contains verbatim book content
- No modifications or interpretations during ingestion

### Example

```json
{
  "id": 42,
  "vector": [0.123, -0.456, ...],  // 1024 dimensions
  "payload": {
    "chapter": "Chapter 1",
    "section": "RAG Architecture",
    "chunk_id": 42,
    "text": "RAG (Retrieval-Augmented Generation) combines retrieval..."
  }
}
```

---

## Entity 4: ConversationSession

**Purpose**: Represents a continuous interaction between a user and the chatbot, maintaining context across multiple exchanges.

### Fields

| Field | Type | Required | Description | Validation |
|-------|------|----------|-------------|-------------|
| `session_id` | `str` | Yes | Unique session identifier | UUID format |
| `messages` | `List[Message]` | Yes | Conversation history | Max 10 messages |
| `created_at` | `datetime` | Yes | Session creation timestamp | ISO 8601 format |
| `last_activity` | `datetime` | Yes | Last message timestamp | ISO 8601 format |

### Sub-entity: Message

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `role` | `str` | Yes | "user" or "assistant" |
| `content` | `str` | Yes | Message text |
| `timestamp` | `datetime` | Yes | When message was created |
| `message_id` | `Optional[str]` | No | UUID for user messages |
| `citations` | `Optional[List[Citation]]` | No | For assistant messages |

### Relationships

- Contains: Many `Message` entities (one-to-many)
- Associated with: WebSocket connection (runtime only, no persistence)

### Validation Rules

**FR-006 (Conversation Context)**:
- `messages` list must not exceed 10 entries (FIFO pruning)
- Messages must be in chronological order
- Each user message must have corresponding assistant message (except in-progress)

**SC-004 (Context Retention)**:
- When limit reached, oldest message pair (user + assistant) is removed first
- Citations are preserved in `Message` objects for historical reference

**User Story 3 (Topic Shift)**:
- Simple keyword matching can detect topic changes
- When detected, consider starting new session (optional enhancement)

### State Transitions

```
[Created] → [Active] → [Pruning] → [Active] → [Idle/Expired]
    ↓           ↓
  (init)   (message exchange)
```

- **Created**: Session initialized on WebSocket connection
- **Active**: User and assistant exchanging messages
- **Pruning**: Automatic removal of old messages when limit reached
- **Idle/Expired**: Session cleanup after 30 minutes of inactivity

### Example

```json
{
  "session_id": "660e9500-f30c-52e5-b827-55776551111",
  "messages": [
    {
      "role": "user",
      "content": "How does RAG retrieval work?",
      "timestamp": "2025-12-30T14:30:00Z",
      "message_id": "550e8400-e29b-41d4-a716-446655440000"
    },
    {
      "role": "assistant",
      "content": "RAG retrieval works by querying a vector database...",
      "timestamp": "2025-12-30T14:30:15Z",
      "citations": [
        {
          "chapter": "Chapter 1",
          "section": "RAG Architecture",
          "chunk_id": 42,
          "relevance_score": 0.89
        }
      ]
    }
  ],
  "created_at": "2025-12-30T14:30:00Z",
  "last_activity": "2025-12-30T14:30:15Z"
}
```

---

## Entity Relationship Diagram

```
┌──────────────────┐
│ ConversationSession│
│ - session_id      │◄───────┐
│ - messages[]      │        │
└──────────────────┘        │
         │                  │
         │ contains         │
         ▼                  │
┌──────────────────┐        │
│     Message     │        │
│ - role          │        │
│ - content       │        │
└──────────────────┘        │
         │                  │
         │ ─────────────────┘
         │
         ├─── "user" → ◄─────┐
         │                      │
         ▼                      │
┌──────────────────┐            │
│     Question     │            │
│ - question      │            │
│ - selected_text │            │
│ - message_id    │            │
└──────────────────┘            │
         │                      │
         │ generates            │
         ▼                      │
┌──────────────────┐            │
│      Answer      │            │
│ - content       │            │
│ - citations[]   │◄───────────┤
│ - confidence    │            │
│ - is_from_book  │            │
└──────────────────┘            │
         │                      │
         │ references           │
         ▼                      │
┌──────────────────┐            │
│     Citation     │            │
│ - chapter       │            │
│ - section       │            │
│ - chunk_id      │            │
└──────────────────┘            │
         │                      │
         │ references           │
         ▼                      │
┌──────────────────┐            │
│  BookContent     │            │
│  (Qdrant Point) │            │
│ - vector        │            │
│ - payload       │            │
└──────────────────┘            │
```

---

## Data Flow

### 1. Ingestion Flow (Book Content → Qdrant)

```
Source Markdown Files
        ↓
    Parse Content
        ↓
    Chunk (500-1000 tokens)
        ↓
    Extract Metadata (chapter, section)
        ↓
    Generate Embeddings (Cohere API)
        ↓
    Upsert to Qdrant (BookContent entity)
```

### 2. Question-Answer Flow

```
WebSocket Connection
        ↓
    Create ConversationSession
        ↓
    Receive Question (with optional selected_text)
        ↓
    Retrieve BookContent (Qdrant search + optional filter)
        ↓
    Generate Answer (OpenAI Agent with retrieved context)
        ↓
    Return Answer with Citations
        ↓
    Update ConversationSession.messages
```

---

## Storage Strategy

| Entity | Storage Type | Rationale |
|--------|-------------|-----------|
| `Question` | Transient (WebSocket message) | No persistence required |
| `Answer` | Transient (WebSocket message) | No persistence required |
| `BookContent` | Qdrant Cloud (Free Tier) | Vector storage + metadata |
| `ConversationSession` | In-memory (dict) | SC-005 (10 concurrent users), no persistence requirement |

---

## Validation Summary

| Entity | Key Validations | Reference |
|--------|----------------|-----------|
| `Question` | 1-500 char question, optional 5000 char selected text | FR-001, FR-003 |
| `Answer` | Non-empty citations when `is_from_book=True` | FR-002, FR-007, Constitution |
| `BookContent` | Unique chunk_id, required metadata | FR-008, FR-010 |
| `ConversationSession` | Max 10 messages, FIFO pruning | FR-006, SC-004 |

All entities align with functional requirements and constitutional principles.
